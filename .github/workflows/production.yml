name: Build and Release Pi Production Images

permissions:
  contents: write
  pull-requests: write
  issues: write
  repository-projects: write

on:
  # Trigger on push to main branch
  push:
    branches:
      - main

  # Trigger from aircast-agent webhook
  repository_dispatch:
    types: [build-production-image]

  workflow_dispatch:
    inputs:
      version:
        description: 'Production version (e.g., v1.0.0)'
        required: true
        type: string

env:
  IMG_NAME: aircast-rpi-arm64

jobs:
  prepare:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event_name == 'repository_dispatch' && github.event.client_payload.ref || github.ref }}

      - name: Determine version
        id: version
        run: |
          if [ "${{ github.event_name }}" == "push" ]; then
            # For branch pushes, generate version from commit SHA
            SHORT_SHA=$(echo "${{ github.sha }}" | cut -c1-7)
            VERSION="v1.0.0.${SHORT_SHA}"
          elif [ "${{ github.event_name }}" == "repository_dispatch" ]; then
            # For webhook triggers from aircast-agent
            VERSION="${{ github.event.client_payload.version }}"
            echo "ğŸ“¨ Triggered by webhook from: ${{ github.event.client_payload.trigger }}"
            echo "ğŸ·ï¸ Agent version: $VERSION"
          else
            # For manual dispatch, use the input
            VERSION="${{ inputs.version }}"
          fi
          
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "ğŸ·ï¸ Production release: $VERSION"

  build:
    needs: prepare
    runs-on: ubuntu-latest-4-cores
    environment: production

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event_name == 'repository_dispatch' && github.event.client_payload.ref || github.ref }}
          fetch-depth: 0

      - name: Cache apt packages
        uses: actions/cache@v4
        with:
          path: /var/cache/apt/archives
          key: apt-${{ runner.os }}-${{ hashFiles('**/production.yml') }}
          restore-keys: |
            apt-${{ runner.os }}-

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            coreutils quilt parted qemu-user-static debootstrap zerofree zip \
            dosfstools libarchive-tools libcap2-bin grep rsync xz-utils file git curl bc \
            gpg pigz xxd arch-test bmap-tools

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3
        with:
          platforms: arm64

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          driver: docker
          install: true

      - name: Create build configuration
        run: |
          echo "ğŸ“ Creating build configuration..."
          cat > config << EOF
          IMG_NAME='aircast-rpi-arm64'
          ENABLE_SSH=1
          FIRST_USER_NAME=pi
          FIRST_USER_PASS=raspberry
          STAGE_LIST="stage0 stage1 stage2 stage3"
          RELEASE=bookworm
          TARGET_HOSTNAME=aircast
          PIGEN_DOCKER_OPTS="--dns 8.8.8.8 --dns 8.8.4.4"
          EOF
          
          echo "âœ… Configuration created"

      - name: Cache Docker layers
        uses: actions/cache@v4
        with:
          path: /tmp/.buildx-cache
          key: buildx-${{ runner.os }}-${{ hashFiles('Dockerfile*', 'stage*/**') }}-${{ github.sha }}
          restore-keys: |
            buildx-${{ runner.os }}-${{ hashFiles('Dockerfile*', 'stage*/**') }}-
            buildx-${{ runner.os }}-

      - name: Cache pi-gen work directory
        uses: actions/cache@v4
        id: cache-work
        with:
          path: |
            work
          key: pi-gen-work-${{ runner.os }}-${{ hashFiles('stage0/**', 'stage1/**', 'stage2/**', 'config') }}
          restore-keys: |
            pi-gen-work-${{ runner.os }}-

      - name: Cache pi-gen build cache
        uses: actions/cache@v4
        id: cache-build
        with:
          path: |
            .build-cache
            work/*.log
          key: pi-gen-build-${{ runner.os }}-${{ hashFiles('config', 'stage*/**') }}
          restore-keys: |
            pi-gen-build-${{ runner.os }}-

      - name: Build Pi image with Docker
        env:
          GITHUB_EVENT_NAME: ${{ github.event_name }}
          GITHUB_WORKFLOW: ${{ github.workflow }}
          GITHUB_REF: ${{ github.ref }}
          PRESERVE_CONTAINER: 1
        run: |
          echo "ğŸš€ Starting Docker-based build..."
          echo "ğŸ“‹ Event: ${{ github.event_name }}"
          echo "ğŸ—‚ï¸ Cache hits:"
          echo "  - Work: ${{ steps.cache-work.outputs.cache-hit }}"
          echo "  - Build: ${{ steps.cache-build.outputs.cache-hit }}"
          
          # Create SKIP files for cached stages to optimize build
          if [ "${{ steps.cache-work.outputs.cache-hit }}" == "true" ]; then
            echo "â­ï¸  Cached work directory found - enabling incremental build"
            # The build scripts will handle SKIP file creation
            export USE_CACHED_STAGES=1
          fi
          
          # Use GitHub-optimized build script if available
          if [ -f ./build-docker-github.sh ]; then
            ./build-docker-github.sh
          else
            # Fallback to regular build
            ./build-docker.sh
          fi
          
          echo "âœ… Build completed successfully!"

      - name: Build Statistics
        if: always()
        run: |
          echo "ğŸ“Š Build Statistics:"
          echo "==================="
          
          # Check cache hit rate and estimate time savings
          if [ "${{ steps.cache-work.outputs.cache-hit }}" == "true" ]; then
            echo "âœ… Incremental build: YES (cached stages available)"
            echo "â±ï¸  Estimated time saved: ~30-45 minutes"
          else
            echo "ğŸ“¦ Full build: YES (all stages)"
            echo "â±ï¸  No cache benefit"
          fi
          
          if [ "${{ steps.cache-build.outputs.cache-hit }}" == "true" ]; then
            echo "âœ… Build cache: HIT"
          else
            echo "ğŸ“¦ Build cache: MISS"
          fi
          
          # Show stage sizes
          echo ""
          echo "ğŸ“ Stage sizes:"
          for stage in stage0 stage1 stage2 stage3; do
            if [ -d "work/$stage" ]; then
              SIZE=$(du -sh "work/$stage" 2>/dev/null | cut -f1 || echo "N/A")
              echo "  - $stage: $SIZE"
            fi
          done
          
          # Show build logs
          if [ -f deploy/build-docker.log ]; then
            echo ""
            echo "â±ï¸  Build time:"
            grep -E "real|user|sys" deploy/build-docker.log | tail -3 || true
          fi

      - name: Prepare artifacts
        id: artifacts
        run: |
          VERSION="${{ needs.prepare.outputs.version }}"
          
          # Find the generated image
          IMAGE_PATH=$(find deploy -name "*.zip" -o -name "*.img" -o -name "*.img.gz" -o -name "*.img.xz" | head -n 1)
          
          if [ -z "$IMAGE_PATH" ]; then
            echo "âŒ No image found in deploy directory"
            exit 1
          fi
          
          echo "ğŸ“¦ Found image: $IMAGE_PATH"
          
          # Get the file extension
          EXT="${IMAGE_PATH##*.}"
          
          # Rename to include version
          NEW_NAME="aircast-rpi-arm64-${VERSION}.${EXT}"
          cp "$IMAGE_PATH" "$NEW_NAME"
          
          echo "image_path=$NEW_NAME" >> $GITHUB_OUTPUT
          echo "image_name=$NEW_NAME" >> $GITHUB_OUTPUT
          
          # Create checksums
          sha256sum "$NEW_NAME" > "${NEW_NAME}.sha256"
          
          echo "âœ… Prepared artifact: $NEW_NAME"

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: pi-image
          path: |
            ${{ steps.artifacts.outputs.image_path }}
            ${{ steps.artifacts.outputs.image_path }}.sha256

  release:
    needs: [prepare, build]
    runs-on: ubuntu-latest
    environment: production

    steps:
      - name: Download artifacts
        uses: actions/download-artifact@v4
        with:
          name: pi-image

      - name: Create GitHub Release
        id: create_release
        uses: softprops/action-gh-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ needs.prepare.outputs.version }}
          name: Aircast Pi Image ${{ needs.prepare.outputs.version }}
          body: |
            ## Aircast Raspberry Pi Image

            This is a production release of the Raspberry Pi image for Aircast.

            ### Installation
            1. Download the image file
            2. Flash it to an SD card using Raspberry Pi Imager or similar tool
            3. Insert the SD card into your Raspberry Pi and boot

            ### Default Credentials
            - Username: `pi`
            - Password: `raspberry`
            - Hostname: `aircast`

            **Important**: Please change the default password after first login!

            ### Checksums
            SHA256 checksums are provided for verification.
          draft: false
          prerelease: false
          files: |
            aircast-rpi-arm64-*.zip
            aircast-rpi-arm64-*.img
            aircast-rpi-arm64-*.img.gz
            aircast-rpi-arm64-*.img.xz
            aircast-rpi-arm64-*.sha256

  mirror-to-s3:
    needs: [prepare, build, release]
    if: needs.release.result == 'success'
    runs-on: ubuntu-latest

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Wait for GitHub release
        run: |
          echo "â³ Waiting for GitHub release to be fully available..."
          sleep 30  # Give GitHub time to process the release

      - name: Download and mirror release assets
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          VERSION="${{ needs.prepare.outputs.version }}"
          echo "ğŸ” Fetching release assets for $VERSION..."
          
          # Get release info
          RELEASE_INFO=$(gh api repos/${{ github.repository }}/releases/tags/$VERSION)
          RELEASE_ID=$(echo "$RELEASE_INFO" | jq -r '.id')
          RELEASE_URL=$(echo "$RELEASE_INFO" | jq -r '.html_url')
          RELEASE_BODY=$(echo "$RELEASE_INFO" | jq -r '.body')
          CREATED_AT=$(echo "$RELEASE_INFO" | jq -r '.created_at')
          
          echo "ğŸ“¦ Found release: $RELEASE_URL"
          
          # Create temp directory for downloads
          mkdir -p temp-assets
          cd temp-assets
          
          # Download all release assets
          echo "ğŸ“¥ Downloading release assets..."
          gh release download $VERSION -R ${{ github.repository }}
          
          # Upload to S3
          echo "ğŸ“¤ Uploading to S3..."
          
          # Upload all image files and checksums
          for file in aircast-rpi-arm64-*; do
            if [ -f "$file" ]; then
              echo "Uploading: $file"
              aws s3 cp "$file" "s3://aircast-artifacts/production/images/$VERSION/$file" --acl public-read
            fi
          done
          
          # Create and upload metadata
          echo "ğŸ“ Creating release metadata..."
          cat > release-metadata.json << EOF
          {
            "version": "$VERSION",
            "release_url": "$RELEASE_URL",
            "created_at": "$CREATED_AT",
            "release_notes": $(echo "$RELEASE_BODY" | jq -Rs .),
            "github_release_id": "$RELEASE_ID",
            "mirror_url": "https://downloads.aircast.one/images/$VERSION/",
            "mirrored_at": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
          }
          EOF
          
          aws s3 cp release-metadata.json "s3://aircast-artifacts/production/images/$VERSION/metadata.json" --acl public-read
          
          # Update latest pointer
          echo "$VERSION" > latest.txt
          aws s3 cp latest.txt "s3://aircast-artifacts/production/images/latest.txt" --acl public-read
          
          # Create latest symlinks for direct download
          echo "ğŸ“ Creating latest symlinks..."
          for file in aircast-rpi-arm64-*; do
            if [ -f "$file" ]; then
              # Extract file extension
              if [[ "$file" == *.zip ]]; then
                aws s3 cp "$file" "s3://aircast-artifacts/production/images/latest/aircast-rpi-arm64-latest.zip" --acl public-read
              elif [[ "$file" == *.sha256 ]]; then
                aws s3 cp "$file" "s3://aircast-artifacts/production/images/latest/aircast-rpi-arm64-latest.zip.sha256" --acl public-read
              fi
            fi
          done
          
          echo "âœ… Mirror complete!"
          echo "ğŸ“ Mirror URL: https://downloads.aircast.one/images/$VERSION/"
          
          cd ..
          rm -rf temp-assets

      - name: Invalidate CloudFront cache
        run: |
          VERSION="${{ needs.prepare.outputs.version }}"
          echo "ğŸ”„ Invalidating CloudFront cache..."
          
          # Find CloudFront distribution for downloads.aircast.one
          DISTRIBUTION_ID=$(aws cloudfront list-distributions \
            --query "DistributionList.Items[?contains(Aliases.Items, 'downloads.aircast.one')].Id" \
            --output text)
          
          if [ -z "$DISTRIBUTION_ID" ]; then
            echo "âš ï¸  Warning: Could not find CloudFront distribution for downloads.aircast.one"
            echo "Please check your CloudFront configuration"
          else
            echo "Found CloudFront distribution: $DISTRIBUTION_ID"
          
            # Create invalidation for latest.txt, latest/* and the new version
            INVALIDATION_ID=$(aws cloudfront create-invalidation \
              --distribution-id $DISTRIBUTION_ID \
              --paths "/images/latest.txt" "/images/$VERSION/*" \
              --query 'Invalidation.Id' \
              --output text)
          
            echo "Created invalidation: $INVALIDATION_ID"
          
            # Wait for invalidation to complete (with timeout)
            echo "Waiting for CloudFront invalidation to complete..."
            timeout 300 aws cloudfront wait invalidation-completed \
              --distribution-id $DISTRIBUTION_ID \
              --id $INVALIDATION_ID || echo "âš ï¸  Invalidation is taking longer than expected"
          
            echo "âœ… CloudFront cache invalidated!"
          fi

  notify:
    needs: [prepare, build, release, mirror-to-s3]
    if: always()
    runs-on: ubuntu-latest

    steps:
      - name: Generate build summary
        run: |
          echo "## ğŸ¥§ Raspberry Pi Image Build Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Trigger:** ${{ github.event_name == 'push' && 'Branch Push' || github.event_name == 'repository_dispatch' && 'Webhook from aircast-agent' || 'Manual Dispatch' }}" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** ${{ needs.prepare.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Timestamp:** $(date -u)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "### Build Status" >> $GITHUB_STEP_SUMMARY
          echo "- **Image Build:** ${{ needs.build.result == 'success' && 'âœ… Success' || 'âŒ Failed' }}" >> $GITHUB_STEP_SUMMARY
          echo "- **GitHub Release:** ${{ needs.release.result == 'success' && 'âœ… Success' || needs.release.result == 'skipped' && 'â­ï¸ Skipped' || 'âŒ Failed' }}" >> $GITHUB_STEP_SUMMARY
          echo "- **S3 Mirror:** ${{ needs.mirror-to-s3.result == 'success' && 'âœ… Success' || needs.mirror-to-s3.result == 'skipped' && 'â­ï¸ Skipped' || 'âŒ Failed' }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ needs.release.result }}" == "success" ]; then
            echo "### ğŸ‰ Release Published" >> $GITHUB_STEP_SUMMARY
            echo "- **GitHub Release:** https://github.com/${{ github.repository }}/releases/tag/${{ needs.prepare.outputs.version }}" >> $GITHUB_STEP_SUMMARY
            if [ "${{ needs.mirror-to-s3.result }}" == "success" ]; then
              echo "- **S3 Mirror:** https://downloads.aircast.one/images/${{ needs.prepare.outputs.version }}/" >> $GITHUB_STEP_SUMMARY
              echo "- **Latest Version:** https://downloads.aircast.one/images/latest.txt" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "### âŒ Build Failed" >> $GITHUB_STEP_SUMMARY
            echo "Check the build logs above for details." >> $GITHUB_STEP_SUMMARY
          fi

      - name: Console output
        run: |
          echo "ğŸ Pi image build completed"
          echo "ğŸ“Š Results:"
          echo "  - Trigger: ${{ github.event_name == 'push' && 'Branch Push' || github.event_name == 'repository_dispatch' && 'Webhook' || 'Manual Dispatch' }}"
          echo "  - Version: ${{ needs.prepare.outputs.version }}"
          echo "  - Build Status: ${{ needs.build.result }}"
          echo "  - Release Status: ${{ needs.release.result }}"
          
          if [ "${{ needs.release.result }}" == "success" ]; then
            echo "ğŸ‰ Pi image release published - check GitHub releases"
          else
            echo "âŒ Build or release failed - check logs for details"
          fi
