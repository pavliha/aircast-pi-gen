name: Build and Release Pi Development Images

permissions:
  contents: write
  pull-requests: write
  issues: write
  repository-projects: write

on:
  # Trigger on push to develop branch
  push:
    branches:
      - develop

  # Trigger from aircast-agent webhook
  repository_dispatch:
    types: [build-image]

  workflow_dispatch:
    inputs:
      version:
        description: 'Development version (e.g., v1.0.0-dev.1)'
        required: true
        type: string

env:
  IMG_NAME: aircast-rpi-arm64

jobs:
  prepare:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Determine version
        id: version
        run: |
          if [ "${{ github.event_name }}" == "push" ]; then
            # For branch pushes, generate version from commit SHA
            SHORT_SHA=$(echo "${{ github.sha }}" | cut -c1-7)
            VERSION="v0.0.0-dev.${SHORT_SHA}"
          elif [ "${{ github.event_name }}" == "repository_dispatch" ]; then
            # For webhook triggers from aircast-agent
            VERSION="${{ github.event.client_payload.version }}"
            echo "üì® Triggered by webhook from: ${{ github.event.client_payload.trigger }}"
            echo "üè∑Ô∏è Agent version: $VERSION"
          else
            # For manual dispatch, use the input
            VERSION="${{ inputs.version }}"
          fi
          
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "üè∑Ô∏è Development release: $VERSION"

  build:
    needs: prepare
    runs-on: [self-hosted, dev]
    environment: development

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Cache apt packages
        uses: actions/cache@v4
        with:
          path: /var/cache/apt/archives
          key: apt-${{ runner.os }}-v1
          restore-keys: |
            apt-${{ runner.os }}-

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            coreutils quilt parted qemu-user-static debootstrap zerofree zip \
            dosfstools libarchive-tools libcap2-bin grep rsync xz-utils file git curl bc \
            gpg pigz xxd arch-test bmap-tools

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3
        with:
          platforms: arm64

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          driver: docker
          install: true

      - name: Create build configuration
        run: |
          echo "üìù Creating build configuration..."
          cat > config << EOF
          IMG_NAME='aircast-rpi-arm64'
          ENABLE_SSH=1
          FIRST_USER_NAME=pi
          FIRST_USER_PASS=raspberry
          STAGE_LIST="stage0 stage1 stage2 stage3"
          RELEASE=bookworm
          TARGET_HOSTNAME=aircast
          PIGEN_DOCKER_OPTS="--dns 8.8.8.8 --dns 8.8.4.4"
          EOF
          
          echo "‚úÖ Configuration created"

      - name: Cache Docker data
        uses: actions/cache@v4
        with:
          path: |
            ~/.docker
          key: docker-${{ runner.os }}-v1
          restore-keys: |
            docker-${{ runner.os }}-

      - name: Cache pi-gen build artifacts
        uses: actions/cache@v4
        id: cache-pigen
        with:
          path: |
            work
            deploy
            .build-cache
          key: pi-gen-${{ runner.os }}-v1
          restore-keys: |
            pi-gen-${{ runner.os }}-
            pi-gen-

      - name: Clean up Docker containers
        run: |
          echo "üßπ Cleaning up any existing Docker containers..."
          docker rm -f pigen_work 2>/dev/null || true
          docker rm -f pigen_work_cont 2>/dev/null || true
          echo "‚úÖ Container cleanup completed"

      - name: Build Pi image with Docker
        env:
          GITHUB_EVENT_NAME: ${{ github.event_name }}
          PRESERVE_CONTAINER: 1
        run: |
          echo "üöÄ Starting Docker-based build..."
          echo "üìã Event: ${{ github.event_name }}"
          echo "üóÇÔ∏è Cache hits:"
          echo "  - Pi-gen artifacts: ${{ steps.cache-pigen.outputs.cache-hit }}"
          
          # Create SKIP files for cached stages to optimize build
          if [ "${{ steps.cache-pigen.outputs.cache-hit }}" == "true" ]; then
            echo "‚è≠Ô∏è  Cached pi-gen artifacts found - enabling incremental build"
            # The build scripts will handle SKIP file creation
            export USE_CACHED_STAGES=1
          fi
          
          # Use GitHub-optimized build script if available
          if [ -f ./build-docker-github.sh ]; then
            ./build-docker-github.sh
          else
            # Fallback to regular build
            ./build-docker.sh
          fi
          
          echo "‚úÖ Build completed successfully!"

      - name: Build Statistics
        if: always()
        run: |
          echo "üìä Build Statistics:"
          echo "==================="
          
          # Check cache hit rate and estimate time savings
          if [ "${{ steps.cache-pigen.outputs.cache-hit }}" == "true" ]; then
            echo "‚úÖ Incremental build: YES (cached artifacts available)"
            echo "‚è±Ô∏è  Estimated time saved: ~30-45 minutes"
          else
            echo "üì¶ Full build: YES (no cache available)"
            echo "‚è±Ô∏è  No cache benefit this run"
          fi
          
          # Show stage sizes
          echo ""
          echo "üìÅ Stage sizes:"
          for stage in stage0 stage1 stage2 stage3; do
            if [ -d "work/$stage" ]; then
              SIZE=$(du -sh "work/$stage" 2>/dev/null | cut -f1 || echo "N/A")
              echo "  - $stage: $SIZE"
            fi
          done
          
          # Show build logs
          if [ -f deploy/build-docker.log ]; then
            echo ""
            echo "‚è±Ô∏è  Build time:"
            grep -E "real|user|sys" deploy/build-docker.log | tail -3 || true
          fi

      - name: Prepare artifacts
        id: artifacts
        run: |
          VERSION="${{ needs.prepare.outputs.version }}"
          
          # Find the generated image
          IMAGE_PATH=$(find deploy -name "*.zip" -o -name "*.img" -o -name "*.img.gz" -o -name "*.img.xz" | head -n 1)
          
          if [ -z "$IMAGE_PATH" ]; then
            echo "‚ùå No image found in deploy directory"
            exit 1
          fi
          
          echo "üì¶ Found image: $IMAGE_PATH"
          
          # Get the file extension
          EXT="${IMAGE_PATH##*.}"
          
          # Rename to include version
          NEW_NAME="aircast-rpi-arm64-${VERSION}.${EXT}"
          cp "$IMAGE_PATH" "$NEW_NAME"
          
          echo "image_path=$NEW_NAME" >> $GITHUB_OUTPUT
          echo "image_name=$NEW_NAME" >> $GITHUB_OUTPUT
          
          # Create checksums
          sha256sum "$NEW_NAME" > "${NEW_NAME}.sha256"
          
          echo "‚úÖ Prepared artifact: $NEW_NAME"

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: pi-image
          path: |
            ${{ steps.artifacts.outputs.image_path }}
            ${{ steps.artifacts.outputs.image_path }}.sha256

  release:
    needs: [prepare, build]
    runs-on: ubuntu-latest
    environment: development

    steps:
      - name: Download artifacts
        uses: actions/download-artifact@v4
        with:
          name: pi-image

      - name: Create GitHub Release
        id: create_release
        uses: softprops/action-gh-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ needs.prepare.outputs.version }}
          name: Aircast Pi Image ${{ needs.prepare.outputs.version }} (Development)
          body: |
            ## Aircast Raspberry Pi Development Image

            This is a development release of the Raspberry Pi image for Aircast.

            ### Installation
            1. Download the image file
            2. Flash it to an SD card using Raspberry Pi Imager or similar tool
            3. Insert the SD card into your Raspberry Pi and boot

            ### Default Credentials
            - Username: `pi`
            - Password: `raspberry`
            - Hostname: `aircast`

            **Important**: Please change the default password after first login!

            ### Checksums
            SHA256 checksums are provided for verification.
          draft: false
          prerelease: true
          files: |
            aircast-rpi-arm64-*.zip
            aircast-rpi-arm64-*.img
            aircast-rpi-arm64-*.img.gz
            aircast-rpi-arm64-*.img.xz
            aircast-rpi-arm64-*.sha256

  mirror-to-s3:
    needs: [prepare, build, release]
    if: needs.release.result == 'success'
    runs-on: ubuntu-latest

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Wait for GitHub release
        run: |
          echo "‚è≥ Waiting for GitHub release to be fully available..."
          sleep 30  # Give GitHub time to process the release

      - name: Download and mirror release assets
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          VERSION="${{ needs.prepare.outputs.version }}"
          echo "üîç Fetching release assets for $VERSION..."
          
          # Get release info
          RELEASE_INFO=$(gh api repos/${{ github.repository }}/releases/tags/$VERSION)
          RELEASE_ID=$(echo "$RELEASE_INFO" | jq -r '.id')
          RELEASE_URL=$(echo "$RELEASE_INFO" | jq -r '.html_url')
          RELEASE_BODY=$(echo "$RELEASE_INFO" | jq -r '.body')
          CREATED_AT=$(echo "$RELEASE_INFO" | jq -r '.created_at')
          
          echo "üì¶ Found release: $RELEASE_URL"
          
          # Create temp directory for downloads
          mkdir -p temp-assets
          cd temp-assets
          
          # Download all release assets
          echo "üì• Downloading release assets..."
          gh release download $VERSION -R ${{ github.repository }}
          
          # Upload to S3
          echo "üì§ Uploading to S3..."
          
          # Upload all image files and checksums
          for file in aircast-rpi-arm64-*; do
            if [ -f "$file" ]; then
              echo "Uploading: $file"
              aws s3 cp "$file" "s3://aircast-artifacts/development/images/$VERSION/$file" --acl public-read
            fi
          done
          
          # Create and upload metadata
          echo "üìù Creating release metadata..."
          cat > release-metadata.json << EOF
          {
            "version": "$VERSION",
            "release_url": "$RELEASE_URL",
            "created_at": "$CREATED_AT",
            "release_notes": $(echo "$RELEASE_BODY" | jq -Rs .),
            "github_release_id": "$RELEASE_ID",
            "mirror_url": "https://downloads.dev.aircast.one/images/$VERSION/",
            "mirrored_at": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
          }
          EOF
          
          aws s3 cp release-metadata.json "s3://aircast-artifacts/development/images/$VERSION/metadata.json" --acl public-read
          
          # Update latest pointer
          echo "$VERSION" > latest.txt
          aws s3 cp latest.txt "s3://aircast-artifacts/development/images/latest.txt" --acl public-read
          
          # Create latest symlinks for direct download
          echo "üìé Creating latest symlinks..."
          for file in aircast-rpi-arm64-*; do
            if [ -f "$file" ]; then
              # Extract file extension
              if [[ "$file" == *.zip ]]; then
                aws s3 cp "$file" "s3://aircast-artifacts/development/images/latest/aircast-rpi-arm64-latest.zip" --acl public-read
              elif [[ "$file" == *.sha256 ]]; then
                aws s3 cp "$file" "s3://aircast-artifacts/development/images/latest/aircast-rpi-arm64-latest.zip.sha256" --acl public-read
              fi
            fi
          done
          
          echo "‚úÖ Mirror complete!"
          echo "üìç Mirror URL: https://downloads.dev.aircast.one/images/$VERSION/"
          
          cd ..
          rm -rf temp-assets

      - name: Invalidate CloudFront cache
        run: |
          VERSION="${{ needs.prepare.outputs.version }}"
          echo "üîÑ Invalidating CloudFront cache..."
          
          # Find CloudFront distribution for downloads.dev.aircast.one
          DISTRIBUTION_ID=$(aws cloudfront list-distributions \
            --query "DistributionList.Items[?contains(Aliases.Items, 'downloads.dev.aircast.one')].Id" \
            --output text)
          
          if [ -z "$DISTRIBUTION_ID" ]; then
            echo "‚ö†Ô∏è  Warning: Could not find CloudFront distribution for downloads.dev.aircast.one"
            echo "Please check your CloudFront configuration"
          else
            echo "Found CloudFront distribution: $DISTRIBUTION_ID"
            
            # Create invalidation for latest.txt, latest/* and the new version
            INVALIDATION_ID=$(aws cloudfront create-invalidation \
              --distribution-id $DISTRIBUTION_ID \
              --paths "/images/latest.txt" "/images/$VERSION/*" \
              --query 'Invalidation.Id' \
              --output text)
            
            echo "Created invalidation: $INVALIDATION_ID"
            
            # Wait for invalidation to complete (with timeout)
            echo "Waiting for CloudFront invalidation to complete..."
            timeout 300 aws cloudfront wait invalidation-completed \
              --distribution-id $DISTRIBUTION_ID \
              --id $INVALIDATION_ID || echo "‚ö†Ô∏è  Invalidation is taking longer than expected"
            
            echo "‚úÖ CloudFront cache invalidated!"
          fi

  notify:
    needs: [prepare, build, release, mirror-to-s3]
    if: always()
    runs-on: ubuntu-latest

    steps:
      - name: Generate build summary
        run: |
          echo "## ü•ß Raspberry Pi Image Build Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Trigger:** ${{ github.event_name == 'push' && 'Branch Push' || github.event_name == 'repository_dispatch' && 'Webhook from aircast-agent' || 'Manual Dispatch' }}" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** ${{ needs.prepare.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Timestamp:** $(date -u)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "### Build Status" >> $GITHUB_STEP_SUMMARY
          echo "- **Image Build:** ${{ needs.build.result == 'success' && '‚úÖ Success' || '‚ùå Failed' }}" >> $GITHUB_STEP_SUMMARY
          echo "- **GitHub Release:** ${{ needs.release.result == 'success' && '‚úÖ Success' || needs.release.result == 'skipped' && '‚è≠Ô∏è Skipped' || '‚ùå Failed' }}" >> $GITHUB_STEP_SUMMARY
          echo "- **S3 Mirror:** ${{ needs.mirror-to-s3.result == 'success' && '‚úÖ Success' || needs.mirror-to-s3.result == 'skipped' && '‚è≠Ô∏è Skipped' || '‚ùå Failed' }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ needs.release.result }}" == "success" ]; then
            echo "### üéâ Release Published" >> $GITHUB_STEP_SUMMARY
            echo "- **GitHub Release:** https://github.com/${{ github.repository }}/releases/tag/${{ needs.prepare.outputs.version }}" >> $GITHUB_STEP_SUMMARY
            if [ "${{ needs.mirror-to-s3.result }}" == "success" ]; then
              echo "- **S3 Mirror:** https://downloads.dev.aircast.one/images/${{ needs.prepare.outputs.version }}/" >> $GITHUB_STEP_SUMMARY
              echo "- **Latest Version:** https://downloads.dev.aircast.one/images/latest.txt" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "### ‚ùå Build Failed" >> $GITHUB_STEP_SUMMARY
            echo "Check the build logs above for details." >> $GITHUB_STEP_SUMMARY
          fi

      - name: Console output
        run: |
          echo "üèÅ Pi image build completed"
          echo "üìä Results:"
          echo "  - Trigger: ${{ github.event_name == 'push' && 'Branch Push' || github.event_name == 'repository_dispatch' && 'Webhook' || 'Manual Dispatch' }}"
          echo "  - Version: ${{ needs.prepare.outputs.version }}"
          echo "  - Build Status: ${{ needs.build.result }}"
          echo "  - Release Status: ${{ needs.release.result }}"
          
          if [ "${{ needs.release.result }}" == "success" ]; then
            echo "üéâ Pi image release published - check GitHub releases"
          else
            echo "‚ùå Build or release failed - check logs for details"
          fi
